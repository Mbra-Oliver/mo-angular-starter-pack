import { inject } from '@angular/core';
import {
  HttpInterceptorFn,
  HttpRequest,
  HttpEvent,
  HttpErrorResponse,
  HttpHandlerFn,
} from '@angular/common/http';
import { Router } from '@angular/router';
import {
  Observable,
  throwError,
  BehaviorSubject,
  filter,
  take,
  switchMap,
  catchError,
  finalize,
} from 'rxjs';
import { AuthService } from 'src/core/services/auth';

// ============================================================================
// AUTH INTERCEPTOR - Gestion automatique des tokens et refresh (Version fonctionnelle)
// ============================================================================

// Variables partag√©es pour g√©rer le refresh token global
let isRefreshing = false;
let refreshTokenSubject: BehaviorSubject<string | null> = new BehaviorSubject<
  string | null
>(null);

export const authTokenInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  // Ignorer les requ√™tes d'authentification pour √©viter les boucles infinies
  if (isAuthRequest(req)) {
    return next(req);
  }

  // Debug pour v√©rifier le token
  const token = authService.getToken();
  console.log('üîë Token disponible:', !!token);
  console.log('üîí Token expir√©:', authService.isTokenExpired());
  console.log('‚úÖ Utilisateur authentifi√©:', authService.isAuthenticated());

  // Ajouter le token si disponible
  const authReq = addTokenHeader(req, authService);

  // Debug pour v√©rifier les headers
  console.log(
    'üì§ Headers de la requ√™te:',
    authReq.headers.get('Authorization')
  );

  return next(authReq).pipe(
    catchError((error: HttpErrorResponse) => {
      console.log('‚ùå Erreur HTTP:', error.status, error.message);

      // Si erreur 401 et que l'utilisateur √©tait authentifi√©, tenter refresh
      if (error.status === 401 && authService.isAuthenticated()) {
        return handle401Error(authReq, next, authService);
      }

      // Si erreur 403, rediriger vers unauthorized
      if (error.status === 403) {
        router.navigate(['/unauthorized']);
      }

      return throwError(() => error);
    })
  );
};

/**
 * V√©rifie si la requ√™te concerne l'authentification
 */
function isAuthRequest(req: HttpRequest<any>): boolean {
  const authUrls = ['/auth/login', '/auth/refresh', '/auth/setup'];
  return authUrls.some((url) => req.url.includes(url));
}

/**
 * Ajoute le token d'authentification √† la requ√™te
 */
function addTokenHeader(
  request: HttpRequest<any>,
  authService: AuthService
): HttpRequest<any> {
  const token = authService.getToken();

  if (token && !authService.isTokenExpired()) {
    console.log('üîê Ajout du token Bearer √† la requ√™te');
    return request.clone({
      headers: request.headers.set('Authorization', `Bearer ${token}`),
    });
  }

  console.log('‚ö†Ô∏è Pas de token valide √† ajouter');
  return request;
}

/**
 * G√®re les erreurs 401 en tentant un refresh token
 */
function handle401Error(
  request: HttpRequest<any>,
  next: HttpHandlerFn,
  authService: AuthService
): Observable<HttpEvent<any>> {
  if (!isRefreshing) {
    isRefreshing = true;
    refreshTokenSubject.next(null);

    const refreshToken = authService.getStoredRefreshToken();

    if (refreshToken) {
      console.log('üîÑ Tentative de refresh token...');
      return authService.refreshToken().pipe(
        switchMap((response: { accessToken: string }) => {
          console.log('‚úÖ Refresh token r√©ussi');
          isRefreshing = false;
          refreshTokenSubject.next(response.accessToken);

          // Retry la requ√™te originale avec le nouveau token
          return next(addTokenHeader(request, authService));
        }),
        catchError((refreshError: any) => {
          console.log('‚ùå Refresh token √©chou√©');
          isRefreshing = false;
          refreshTokenSubject.next(null);

          // Refresh √©chou√©, d√©connecter l'utilisateur
          authService.logout();
          return throwError(() => refreshError);
        }),
        finalize(() => {
          isRefreshing = false;
        })
      );
    } else {
      console.log('‚ùå Pas de refresh token, d√©connexion');
      // Pas de refresh token, d√©connecter
      authService.logout();
      return throwError(
        () => new Error('Token expir√© et pas de refresh token')
      );
    }
  }

  // Si un refresh est d√©j√† en cours, attendre qu'il se termine
  return refreshTokenSubject.pipe(
    filter((token): token is string => token !== null),
    take(1),
    switchMap((token) => next(addTokenHeader(request, authService)))
  );
}
